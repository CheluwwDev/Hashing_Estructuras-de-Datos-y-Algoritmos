## README | Hashing perfecto, hashing abierto y hashing cerrado.

Nuestro equipo decidió investigar a fondo el fascinante mundo del hashing, centrándonos específicamente en perfecto, abierto y cerrado. Consideramos crucial el estudio de estas técnicas, ya que son pilares en la revolución tecnológica actual, donde el manejo correcto de los datos determina el éxito de los sistemas y plataformas informaticos. Su relevancia se aprecia en la optimización del tiempo de acceso al gestionar grandes volúmenes de data, el impacto en el rendimiento de aplicaciones cuando ocurren colisiones, y la escalabilidad en la gestión de estructuras de datos dinámicas. Estas técnicas no solo son teóricamente elegantes, sino que representan soluciones prácticas a problemas reales en áreas que van desde la inteligencia artificial hasta los sistemas distribuidos, lo que las convierte en un campo de estudio tan necesario como apasionante.

## Comenzando 
  ### Pre-requisitos 📋
Descargar y hacer uso de un Entorno de Desarrollo Integrado (IDE) que permita ejecutar archivos .cs (archivos de C#). 
```
Por ejemplo: Visual Studio o Visual Studio Code
```

### Ejecución 🔧
Abra su IDE preferido y abra una nueva carpeta (adjuntada en esta entrega). Cuando la cargue correctamente en su IDE, ejécutela y podrá apreciar la funcionalidad del código.
Por medio de la documentación correspondiente dentro del código, podrá indentifcar las implementaciones de Hashing perfecto, Hashing abierto y Hashing cerrado.
```
codigos_hasheo.cs
```
## Ejecutando las pruebas ⚙️
Nos aseguramos de que las funciones distribuyen y organizan correctamente las claves. Asimismo, las busquedas devuelven resultados esperados. Se evitaron y arreglaron bugs y colisiones posibles. 

Las pruebas son importantes para garantizar la calidad de esta investigación. ;)


### Estilo de codificación ⌨️
Se utlizó PascalCase para clases y métodos. camelCase, se implementó en variables y parámetros. Está correctamente documentado con código claro para que haya una mejor comprensión por parte del receptor y entre miembros del equipo. En el caso del hashing perfecto, hay un primer nivel con la clase Hash simple y un segundo nivel con tabla tamaño n² y dispersión ajustable. Esto evita colisiones con conjuntos de datos pequeños. Implementamos el Array.fill para evitar redundar con tantos bucles. En conclusión, nos basamos en un estilo simple, legible y agradable para que nos sintieramos comodos con su sintaxis.

## Terminos y condiciones del equipo desarrollador
El equipo no se hace responsable por cualquier error en la ejecución de las pruebas. Ya que tenemos al profe mas crack impartiendonos EDA.
Además, fue divertido e importante desarrollar la investigación. Nos llevamos un aprendizaje enorme de esta materia y esperamos que nos impulse a motivarnos en actividades similares. 

## Versionado 
La demostración por medio de código funcional ha sido manejada en github y puede acceder a esta por medio de este enlace: 

## Autores ✒️
El grupo se conforma por estas grandes mentes intelectuales que no pierden ningún desafio y siempre buscan la excelencia:

Kathleen Abigail Argueta Gómez 
Alejandro Javier Durón Rodriguez 
Lorena Esmeralda Mejía Ramos 
Reina Arely Sosa Mejía
Iván Alessandro Vásquez Martínez

## Licencia 📄
Este proyecto está bajo la Licencia de nuestro grupo y no puede ser plagiado por terceros al equipo organizador de este increible proyecto.
